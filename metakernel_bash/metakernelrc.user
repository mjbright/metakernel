
## ----------------------------------------
## Configuration:

[ -z "$USER" ] && USER="unknown"

TMPDIR=/tmp/metakernel_bash_kernel

function reread_user_metakernelrc { source ${BASH_SOURCE[0]}; }

## ----------------------------------------
## Startup:

#
# These get echoed if re-sourced from the notebook
#      source ~/.metakernelrc
MESSAGE="[$(date)] Sourcing <<${BASH_SOURCE[0]}>>"
echo $MESSAGE
#echo $MESSAGE >&2

[ ! -d $TMPDIR ] && mkdir -p $TMPDIR
echo $MESSAGE >> $TMPDIR/metakernelrc.${USER}.sourced

utest_fn() {
    MESSAGE="[$(date)] Hello from utest_fn() (declared in ${BASH_SOURCE[0]})"
    echo $MESSAGE
}


## ----------------------------------------
## User functions:

#
# Function: pydot_show_filetree_perl
# Usage: find /tmp/ | pydot_show_filetree
pydot_show_filetree_perl() {
    echo "Invoked ${FUNCNAME[0]} $*" >&2

    perl -ne '
  BEGIN {
    print "digraph G {\n  edge [color=blue, arrowsize=2];\n  node [color=lightyellow2, style=filled];\n";
  };

  chomp();
  if (!defined($ROOT)) {
    $ROOT="$_"; $ROOT =~ s/\//_/g;
    $ROOTLABEL=$_;
    $NODES{$ROOT}="root";
    print "\n  $ROOT [label=\"$ROOTLABEL\"];\n"; 
  } else {
    m/^(.+)\/([^\/]+)/;
    ($PARENT,$CHILD)=($1,$2);
    $NODE = $_;
    $NODE =~ s/\//_/g;
    $PARENTNODE = $PARENT;
    $PARENTNODE =~ s/\//_/g;

    $NODES{$NODE}=$CHILD;
    print "  $PARENTNODE -> $NODE;\n";
    print "\n  $NODE [label=\"$CHILD\"];\n"; 
};

    END { print "}\n"; }; ' | pydot
}


#
# Function: pydot_show_filetree
# Usage: find /tmp/ | pydot_show_filetree
pydot_show_filetree_python_test() {
    echo "Invoked ${FUNCNAME[0]} $*" >&2

    python -c '
print("digraph G { \
        edge [color=blue, arrowsize=2]; \
        node [color=lightyellow2, style=filled]; \
        root -> f1; \
        root -> f2; \
        f1 -> f4;\
        f3 -> f5; \
        f3 -> f6; \
        f2 -> f3; \
        root [label=\"/tmp/findtest\"]; \
        f1 [label=\"file1\"]; \
        f2 [label=\"file2\"]; \
        f3 [label=\"file3\"]; \
        f4 [label=\"file4\"]; \
        f5 [label=\"file5\"]; \
        f6 [label=\"file6\"]; \
} ") ' | pydot
#} ") '
}


#
# Function: pydot_show_filetree
# Usage: find /tmp/ | pydot_show_filetree
pydot_show_filetree() {
  echo "Invoked ${FUNCNAME[0]} $*" >&2

  PYSCRIPT=${ROOT_PATH_PREFIX}$TMPDIR/${FUNCNAME[0]}.py

  cat <<EOF > $PYSCRIPT

import sys

lines = sys.stdin.readlines()

print("digraph G {\
  edge [color=blue, arrowsize=2];\
  node [color=lightyellow2, style=filled];\
")

ROOT=None
NODES=dict()

for line in lines:
  line=line.strip()
  if ROOT == None:
    ROOT=line.replace('/','_')
    ROOTLABEL=line;
    NODES[ROOT]="root"
    print()
    print('  "{}" [label="{}"];'.format( ROOT, ROOTLABEL) )
  else:
    PARENT=line[:line.rfind('/')]
    CHILD=line[1+line.rfind('/'):]
    NODE = line.replace('/','_')
    PARENTNODE = PARENT.replace('/','_')

    NODES[NODE]=CHILD
    print('  "{}" -> "{}";'.format(PARENTNODE, NODE))
    print()
    print('  "{}" [label="{}"];'.format(NODE, CHILD))

print("}\n")
EOF
  python $PYSCRIPT |& tee $TMPDIR/${FUNCNAME[0]}.pydot | pydot
}

#
# Function: pydot_show_du
# Usage: du -s /tmp/* | pydot_show_du
# Inspired by
#     http://stackoverflow.com/questions/28670676/graphviz-python-node-shapes-pie-chart-in-a-node
pydot_show_du() {
  echo "Invoked ${FUNCNAME[0]} $*" >&2

  MAX_ITEMS=10
  [ ! -z "$1" ] && MAX_ITEMS=$1

  PYSCRIPT=${ROOT_PATH_PREFIX}$TMPDIR/${FUNCNAME[0]}.py

  cat <<EOF > $PYSCRIPT

import sys

lines = sys.stdin.readlines()

print("digraph G {\
    rankdir=LR;\
    node [shape=plaintext style=\"filled\"];\
    subgraph cluster_01 { \
      label = \"du\";\
      key3 [label=\"key3\"]\
      key2 [label=\"key2\"]\
      key1 [label=\"key1\"]\
    };\
    node [shape=circle fizedsize=true width=10 style=wedged fillcolor=\"red;0.3:green;0.6:orange\"];\
    A\
")

for line in lines:
  line=line.strip()

print("}\n")
EOF

  sort -nr | tail -$MAX_ITEMS | python $PYSCRIPT |& tee $TMPDIR/${FUNCNAME[0]}.pydot | pydot
}


## html_table
# Description: Demonstrates how to convert 'mysql' (or OpenStack cli) table output to html,
#              can be piped to 'html' for rendering
html_table() {
  echo "Invoked ${FUNCNAME[0]} $*" >&2

  PYSCRIPT=${ROOT_PATH_PREFIX}$TMPDIR/${FUNCNAME[0]}.py

  cat <<EOF > $PYSCRIPT

import IPython

# This is nice to have but we want rather something which is callable from a bash kernel
# how?
def displayMysqlTableTextAsHTML(lines):
    header=False
    colNames=[]
    values=[]
    for line in lines:
        line = line.strip()
        row=[]
        if len(line) != 0 and line[0] != '+' and line[0] == '|':
            if not header:
                header=True
                colNames = [ colName.strip() for colName in (line.strip())[1:-1].split('|')]
            else:
                row      = [ value.strip()   for value   in (line.strip())[1:-1].split('|')]
                values.append(row)

    table = '<table>' +         '<tr>' + '\n'.join( [ '<th>'+colName+'</th>' for colName in colNames ] ) + '\n</tr>\n' +         '\n'.join([ '<tr>'+             '\n    '.join( [ '<td>'+value+'</td>' for value in row ] ) +
          '\n</tr>' for row in values ]) +        '</table>'

    return table


import sys

lines=sys.stdin.readlines()
retval = displayMysqlTableTextAsHTML(lines)
print(retval)

EOF

  python $PYSCRIPT |& tee $TMPDIR/${FUNCNAME[0]}.stdout 
}

## test_html_table
# Description: Demonstrates how to convert 'mysql' (or OpenStack cli) table output to html,
#              can be piped to 'html' for rendering
test_html_table() {
  echo "Invoked ${FUNCNAME[0]} $*" >&2

  PYSCRIPT=${ROOT_PATH_PREFIX}$TMPDIR/${FUNCNAME[0]}.py

  cat <<EOF > $PYSCRIPT

import IPython

# This is nice to have but we want rather something which is callable from a bash kernel
# how?
def displayMysqlTableTextAsHTML(text):
    header=False
    colNames=[]
    values=[]
    for line in text.split('\n'):
        line = line.strip()
        row=[]
        if len(line) != 0 and line[0] != '+' and line[0] == '|':
            if not header:
                header=True
                colNames = [ colName.strip() for colName in (line.strip())[1:-1].split('|')]
            else:
                row      = [ value.strip()   for value   in (line.strip())[1:-1].split('|')]
                values.append(row)

    table = '<table>' +         '<tr>' + '\n'.join( [ '<th>'+colName+'</th>' for colName in colNames ] ) + '\n</tr>\n' +         '\n'.join([ '<tr>'+             '\n    '.join( [ '<td>'+value+'</td>' for value in row ] ) +
          '\n</tr>' for row in values ]) +        '</table>'

    return table

text='''
+-------+-------+-------+-----+
  |  col1 | col2  |  col3 |col4 |  
+-------+-------+-------+-----+
|  val1 | val2  |  val3 |val4 |
|  valu1|value2 |value3|val4|
+-------+-------+-------+-----+
'''

retval = displayMysqlTableTextAsHTML(text)
print(retval)

EOF

  python $PYSCRIPT |& tee $TMPDIR/${FUNCNAME[0]}.stdout 
}

# Implement lightning

# lightning_line plot:
lightning_line_test() {
  echo "Invoked ${FUNCNAME[0]} $*" >&2

  # NOTE use of '_' to prevent trying to import itself!
  PYSCRIPT=${ROOT_PATH_PREFIX}$TMPDIR/_${FUNCNAME[0]}.py

  cat <<EOF > $PYSCRIPT

import IPython
from lightning import Lightning
lgn = Lightning(host="http://public.lightning-viz.org")

#from numpy import random
#viz = lgn.line(random.random(10))
#
from numpy import random, asarray
series = random.randn(5, 50)
#print(str(series))
viz = lgn.line(series)

print( viz.get_html() )

EOF

  python $PYSCRIPT |& tee $TMPDIR/${FUNCNAME[0]}.stdout 
}

# bokeh_line plot:
bokeh_line_test() {
  echo "Invoked ${FUNCNAME[0]} $*" >&2

  # NOTE use of '_' to prevent trying to import itself!
  PYSCRIPT=${ROOT_PATH_PREFIX}$TMPDIR/_${FUNCNAME[0]}.py

  cat <<EOF > $PYSCRIPT

#from ipywidgets import interact
import numpy as np

from bokeh.io import push_notebook
from bokeh.plotting import figure, show, output_file

from bokeh.resources import CDN
from bokeh.embed import file_html

x = np.linspace(0, 2*np.pi, 2000)
y = np.sin(x)

p = figure(title="simple line example", plot_height=300, plot_width=600, y_range=(-5,5))
r = p.line(x, y, color="#2222aa", line_width=3)

html = file_html(p, CDN, "my 2nd plot")
print(html)
#DONT PRINT - this crashes the browser tab: print(html)
#
#import IPython
#retval=IPython.display.HTML(html)
#
EOF

  python $PYSCRIPT |& tee $TMPDIR/${FUNCNAME[0]}.stdout 
}

# bokeh_piechart plot:
bokeh_piechart_test() {
  echo "Invoked ${FUNCNAME[0]} $*" >&2

  # NOTE use of '_' to prevent trying to import itself!
  PYSCRIPT=${ROOT_PATH_PREFIX}$TMPDIR/_${FUNCNAME[0]}.py

  cat <<EOF > $PYSCRIPT

from bokeh.plotting import *
from bokeh.resources import CDN
from bokeh.embed import file_html
from numpy import pi

# define starts/ends for wedges from percentages of a circle
percents = [0, 0.3, 0.4, 0.6, 0.9, 1]
legends = ["A", "B", "C", "D", "E", "F"]
starts = [p*2*pi for p in percents[:-1]]
ends = [p*2*pi for p in percents[1:]]

# a color for each pie piece
colors = ["red", "green", "blue", "orange", "yellow"]

p = figure(x_range=(-1,1), y_range=(-1,1))

p.wedge(x=0, y=0, radius=1, start_angle=starts, end_angle=ends, color=colors)

# save everything:
#output_file("pie.html")
#show(p)

html = file_html(p, CDN, "my pie-chart plot")
print(html)

EOF

  python $PYSCRIPT |& tee $TMPDIR/${FUNCNAME[0]}.stdout 
}

csv_date_linechart() {

  echo "Invoked ${FUNCNAME[0]} $*" >&2

  # After call, data will be in file $TMPFILE:
  getinput_src "${FUNCNAME[0]}" "$1"

  # Copy TMPFILE to local ./tmp/
  [ ! -d tmp ] && mkdir -p tmp
  cp $TMPFILE ./tmp/
  TMPFILE=tmp/${TMPFILE##*/}
  echo "csv_linechart: data file=$TMPFILE"

  HTMLSCRIPT=${ROOT_PATH_PREFIX}$TMPDIR/${FUNCNAME[0]}.html

  cat <<EOF > $HTMLSCRIPT
<!DOCTYPE html>
<meta charset="utf-8">
<style> /* set the CSS */

body { font: 12px Arial;}

path { 
    stroke: steelblue;
    stroke-width: 2;
    fill: none;
}

.axis path,
.axis line {
    fill: none;
    stroke: grey;
    stroke-width: 1;
    shape-rendering: crispEdges;
}

</style>
<div id="myd3_date_linechart">

<!-- load the d3.js library -->    
<script src="http://d3js.org/d3.v3.min.js"></script>

<script>

// Set the dimensions of the canvas / graph
var margin = {top: 30, right: 20, bottom: 30, left: 50},
    width = 600 - margin.left - margin.right,
    height = 270 - margin.top - margin.bottom;

// Parse the date / time
var parseDate = d3.time.format("%d-%b-%y").parse;

// Set the ranges
var x = d3.time.scale().range([0, width]);
var y = d3.scale.linear().range([height, 0]);

// Define the axes
var xAxis = d3.svg.axis().scale(x)
    .orient("bottom").ticks(5);

var yAxis = d3.svg.axis().scale(y)
    .orient("left").ticks(5);

// Define the line
var valueline = d3.svg.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.yValue); });
    
// Adds the svg canvas
var svg = d3.select("#myd3_date_linechart")
    .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
    .append("g")
        .attr("transform", 
              "translate(" + margin.left + "," + margin.top + ")");

// Get the data
d3.csv("$TMPFILE", function(error, data) {
    data.forEach(function(d) {
        d.date = parseDate(d.date);
        d.yValue = +d.yValue;
    });

    // Scale the range of the data
    x.domain(d3.extent(data, function(d) { return d.date; }));
    y.domain([0, d3.max(data, function(d) { return d.yValue; })]);

    // Add the valueline path.
    svg.append("path")
        .attr("class", "line")
        .attr("d", valueline(data));

    // Add the X Axis
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    // Add the Y Axis
    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis);

});

</script>
</div>

EOF

  cat $HTMLSCRIPT |& tee $TMPDIR/${FUNCNAME[0]}.stdout | html
}

csv_linechart() {

  echo "Invoked ${FUNCNAME[0]} $*" >&2

  # After call, data will be in file $TMPFILE:
  getinput_src "${FUNCNAME[0]}" "$1"

  # Copy TMPFILE to local ./tmp/
  #TMPFILE=${{ROOT_PATH_PREFIX}${TMPFILE}
  [ ! -d tmp ] && mkdir -p tmp
  cp $TMPFILE ./tmp/
  TMPFILE=tmp/${TMPFILE##*/}
  echo "csv_linechart: data file=$TMPFILE"

  HTMLSCRIPT=${ROOT_PATH_PREFIX}$TMPDIR/${FUNCNAME[0]}.html

  cat <<EOF > $HTMLSCRIPT
<!DOCTYPE html>
<meta charset="utf-8">
<style> /* set the CSS */

body { font: 12px Arial;}

path { 
    stroke: steelblue;
    stroke-width: 2;
    fill: none;
}

.axis path,
.axis line {
    fill: none;
    stroke: grey;
    stroke-width: 1;
    shape-rendering: crispEdges;
}

</style>
<div id="myd3_linechart">

<!-- load the d3.js library -->    
<script src="http://d3js.org/d3.v3.min.js"></script>

<script>

// Set the dimensions of the canvas / graph
var margin = {top: 30, right: 20, bottom: 30, left: 50},
    width = 600 - margin.left - margin.right,
    height = 270 - margin.top - margin.bottom;

// Set the ranges
var x = d3.scale.linear().range([0, width]);
var y = d3.scale.linear().range([height, 0]);

// Define the axes
var xAxis = d3.svg.axis().scale(x)
    .orient("bottom").ticks(5);

var yAxis = d3.svg.axis().scale(y)
    .orient("left").ticks(5);

// Define the line
var valueline = d3.svg.line()
    .x(function(d) { return x(d.xValue); })
    .y(function(d) { return y(d.yValue); });
    
// Adds the svg canvas
var svg = d3.select("#myd3_linechart")
    .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
    .append("g")
        .attr("transform", 
              "translate(" + margin.left + "," + margin.top + ")");

// Get the data
d3.csv("$TMPFILE", function(error, data) {
    data.forEach(function(d) {
        d.xValue = d.xValue;
        d.yValue = +d.yValue;
    });

    // Scale the range of the data
    x.domain(d3.extent(data, function(d) { return d.xValue; }));
    y.domain([0, d3.max(data, function(d) { return d.yValue; })]);

    // Add the valueline path.
    svg.append("path")
        .attr("class", "line")
        .attr("d", valueline(data));

    // Add the X Axis
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    // Add the Y Axis
    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis);

});

</script>
</div>

EOF

  cat $HTMLSCRIPT |& tee $TMPDIR/${FUNCNAME[0]}.stdout | html
}

csv_d3piechart_0() {
    DATA_CSV="$1"; shift

    # After call, data will be in file $TMPFILE:
    GETINPUT ${FUNCNAME[0]} "$DATA_CSV"
    COPY_TMPFILE
    DATA_CSV=$TMPFILE

    DIV_ID=${FUNCNAME[0]}_$(date +%s)
    # USE_TEMPLATE <template> <input-file> <div-id>
    USE_TEMPLATE d3_pie_0.js.template "$DATA_CSV" "$DIV_ID" | html
}

csv_d3piechart() {
    DATA_CSV="$1"; shift

    # After call, data will be in file $TMPFILE:
    GETINPUT ${FUNCNAME[0]} "$DATA_CSV"
    COPY_TMPFILE
    DATA_CSV=$TMPFILE

    DIV_ID=${FUNCNAME[0]}_$(date +%s)
    # USE_TEMPLATE <template> <input-file> <div-id>
    USE_TEMPLATE d3_pie.js.template "$DATA_CSV" "$DIV_ID" | html
}

du_d3piechart() {

    if [ -z "$DU_MAX" ];then
        du $* | sort -nr
    else
        du $* | sort -nr | head -$DU_MAX
    fi | awk 'BEGIN { print "item,value";}; { print $2","$1;}' | csv_d3piechart
}

test_piechart_js() {
    # After call, data will be in file $TMPFILE:
    GETINPUT ${FUNCNAME[0]} "$DATA_CSV"
    COPY_TMPFILE
    DATA_CSV=$TMPFILE

    # USE_TEMPLATE <template> <input-file> <div-id>
    USE_TEMPLATE d3_pie.js.template "$1" "test_piechart" | html
}

test_alert_js() {
    # USE_TEMPLATE <template> <alert-message>
    USE_TEMPLATE alert.js.template "$1" | js
}

html_find() {
  {
    echo "+------+";
    echo "| Path |" ;
    echo "+------+";

    find "$@" | sed -e 's/^/\| /' -e 's/$/ \|/' ;

    echo "+------+" ;
  } | html_table | html
}

